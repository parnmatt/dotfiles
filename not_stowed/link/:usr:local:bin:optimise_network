#!/usr/bin/env python

import argparse
from collections import namedtuple
import contextlib
import datetime
import glob
import itertools
import re
import subprocess
import os

import Reflector
import speedtest


def _current_network():
    """Returns string of current network via `netctl-auto`."""
    with subprocess.Popen('netctl-auto list', shell=True,
                          stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE) as proc:
        networks, error = proc.communicate()
        if error:
            raise PermissionError('Run as root')
        networks = re.split(r'\n\s*', networks.decode().strip())
        networks = (network.strip('* ')
                    for network in networks
                    if network.startswith('*'))
    return next(networks)


NETWORK = _current_network()

NetworkSpeed = namedtuple('NetworkSpeed', ('download', 'upload'))


def _network_speed():
    """Calculate current download and upload speeds in kiB."""
    tester = speedtest.Speedtest(units=('byte', 1))
    tester.get_best_server()

    download = tester.download() / 1024  # kiB
    upload = tester.upload() / 1024  # kiB
    return NetworkSpeed(download, upload)


def _link(src, dest):
    """Symbolic link `src` to `dest`."""
    os.makedirs(os.path.dirname(dest), exist_ok=True)
    with contextlib.suppress(FileNotFoundError):
        os.remove(dest)
    os.symlink(src, dest)


def _is_filename_older_than(filename, older_than=None):
    """Checks if a file is older than a datetime.timedelta."""
    if older_than is None:
        return True

    now = datetime.datetime.now()
    mtime = os.path.getmtime(filename)
    last_modified = datetime.datetime.fromtimestamp(mtime)
    return now - last_modified > older_than


class Service():
    def _filename(self, network_name, expression=True):
        basename = network_name
        if expression:
            basename = self.conf_expression.format(network_name)
        return os.path.join(self.path, basename)

    def __init__(self, path, conf_expression, conf_name):
        self.path = path
        self.conf_expression = conf_expression
        self.service_file = self._filename(conf_name, expression=False)

    def link(self):
        """Symbolic link service configuration for current network"""
        print('Linking {} configuration'.format(self.__class__.__name__))
        _link(self._filename(NETWORK), self.service_file)

    def optimise(self, older_than=None):
        """
        Optmise the service if the rTorrent file's modification time is
        older than the given datetime.timedelta object, or None.
        """

        if os.path.exists(self.service_file) and \
                not _is_filename_older_than(self.service_file, older_than):
            return

        print('Optimising {}'.format(self.__class__.__name__))
        self._optimise()

    def _optimise(self):
        raise NotImplementedError('_optimise() needs to be implemented for each inherited service')


class rTorrent(Service):
    def __init__(self):
        super().__init__('/etc/rtorrent', '{}.conf', 'network.conf')

    def _optimise(self):
        """
        Optimise rTorrent's settings and writes to
        /etc/rtorrent/NETWORK.conf. Sets the global download and upload
        rates, and the maximum connected peers, and the maxiumum simulaneous
        uploads.
        """
        speed = _network_speed()

        settings = {
                'download_rate': 0.95 * speed.download,
                'upload_rate': 0.8 * speed.upload,
                }
        settings.update({
            'max_peers': 1.3 * settings['upload_rate'],
            'max_uploads': 1 + settings['upload_rate']/6,
            })

        # round down to integers
        settings = {setting: int(value) for setting, value in settings.items()}

        # create config file
        os.makedirs(os.path.dirname(self.service_file), exist_ok=True)
        with open(self.service_file, 'w') as file:
            for setting, value in settings.items():
                print(setting, '=', value, file=file)


class Pacman(Service):
    def __init__(self):
        super().__init__('/etc/pacman.d', 'mirrorlist.{}', 'mirrorlist')

    def _optimise(self):
        """
        Optimises pacman mirrorlist using `reflector` and writes to
        /etc/pacman.d/mirrorlist.NETWORK Selects the 10 fastest servers
        from the 50 most up-to-date servers using the HTTP protocal.
        """
        settings = {
                'protocol': 'http',
                'latest': 50,
                'fastest': 10,
                'save': self.service_file,
                }

        reflector_args = tuple(itertools.chain.from_iterable(
            ('--{}'.format(setting), '{}'.format(value))
            for setting, value in settings.items()))
        Reflector.main(reflector_args)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='Optimise network based things')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-f', '--force', action='store_true',
                       help='forcibly optimise')
    group.add_argument('-l', '--link-only', action='store_true',
                       help='link only, do not optimise')
    args = parser.parse_args()

    services = Pacman(), rTorrent()

    if args.force:
        for service in services:
            service.optimise()
    elif not args.link_only:
        for service in services:
            service.optimise(older_than=datetime.timedelta(weeks=1))

    for service in services:
        service.link()
