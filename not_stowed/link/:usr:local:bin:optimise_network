#!/usr/bin/env python

import argparse
from collections import namedtuple
import contextlib
import datetime
import inspect
import itertools
import re
import subprocess
import sys
import os

import Reflector
import speedtest


def _current_network():
    """Returns string of current network via `netctl-auto`."""
    with subprocess.Popen('netctl-auto list', shell=True,
                          stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE) as proc:
        networks, error = proc.communicate()
        if error:
            raise PermissionError('Run as root')
        networks = re.split(r'\n\s*', networks.decode().strip())
        networks = (network.strip('* ')
                    for network in networks
                    if network.startswith('*'))
    return next(networks)


NETWORK = _current_network()

NetworkSpeed = namedtuple('NetworkSpeed', ('download', 'upload'))


def _network_speed():
    """Calculate current download and upload speeds in kiB."""
    tester = speedtest.Speedtest(units=('byte', 1))
    tester.get_best_server()

    download = tester.download() / 1024  # kiB
    upload = tester.upload() / 1024  # kiB
    return NetworkSpeed(download, upload)


def _link(src, dest):
    """Symbolic link `src` to `dest`."""
    os.makedirs(os.path.dirname(dest), exist_ok=True)
    with contextlib.suppress(FileNotFoundError):
        os.remove(dest)
    os.symlink(src, dest)


def _execute_all(self, prefix, **kwargs):
    """Run all functions that start with `prefix`."""
    for name, obj in inspect.getmembers(sys.modules[__name__]):
        if inspect.isfunction(obj) and \
                obj.__name__.startswith(prefix) and \
                obj is not self:
            obj(**kwargs)


def _is_filename_older_than(filename, older_than=None):
    """Checks if a file is older than a datetime.timedelta."""
    if older_than is None:
        return True

    now = datetime.datetime.now()
    mtime = os.path.getmtime(filename)
    last_modified = datetime.datetime.fromtimestamp(mtime)
    return now - last_modified > older_than


def optimise_all(older_than=None):
    return _execute_all(optimise_all, 'optimise_', older_than=older_than)


def link_all():
    return _execute_all(link_all, 'link_')


# rTorrent
RTORRENT_PATH = '/etc/rtorrent'
RTORRENT_FILE = os.path.join(RTORRENT_PATH, NETWORK + '.conf')


def link_rtorrent():
    print('Linking rTorrent configuration')
    _link(RTORRENT_FILE, os.path.join(RTORRENT_PATH, 'network.conf'))


def optimise_rtorrent(older_than=None):
    """
    Optimise rTorrent's settings and writes to
    /etc/rtorrent/NETWORK.conf. Sets the global download and upload
    rates, and the maximum connected peers, and the maxiumum simulaneous
    uploads; if the rTorrent file's modification time is older than the
    given datetime.timedelta object, or None.
    """
    if os.path.exists(RTORRENT_FILE) and \
            not _is_filename_older_than(RTORRENT_FILE, older_than):
        return

    print('Optimising rTorrent')

    speed = _network_speed()

    settings = {
            'download_rate': 0.95 * speed.download,
            'upload_rate': 0.8 * speed.upload,
            }
    settings.update({
        'max_peers': 1.3 * settings['upload_rate'],
        'max_uploads': 1 + settings['upload_rate']/6,
        })

    # round down to integers
    settings = {setting: int(value) for setting, value in settings.items()}

    # create config file
    os.makedirs(os.path.dirname(RTORRENT_FILE), exist_ok=True)
    with open(RTORRENT_FILE, 'w') as file:
        for setting, value in settings.items():
            print(setting, '=', value, file=file)


# pacman
PACMAN_PATH = '/etc/pacman.d'
PACMAN_MIRRORLIST_FILE = os.path.join(PACMAN_PATH, 'mirrorlist.' + NETWORK)


def link_pacman_mirrorlist():
    print('Linking pacman mirrorlist')
    _link(PACMAN_MIRRORLIST_FILE, os.path.join(PACMAN_PATH, 'mirrorlist'))


def optimise_pacman_mirrorlist(older_than=None):
    """
    Optimises pacman mirrorlist using `reflector` and writes to
    /etc/pacman.d/mirrorlist.NETWORK Selects the 10 fastest servers
    from the 50 most up-to-date servers using the HTTP protocal;
    if the mirrorlist's modification time is older than the given
    datetime.timedelta object, or None.
    """
    if os.path.exists(PACMAN_MIRRORLIST_FILE) and \
            not _is_filename_older_than(PACMAN_MIRRORLIST_FILE, older_than):
        return

    print('Optimising pacman mirrorlist')

    settings = {
            'protocol': 'http',
            'latest': 50,
            'fastest': 10,
            'save': PACMAN_MIRRORLIST_FILE,
            }

    reflector_args = tuple(itertools.chain.from_iterable(
        ('--{}'.format(setting), '{}'.format(value))
        for setting, value in settings.items()))
    Reflector.main(reflector_args)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='Optimise network based things')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-f', '--force', action='store_true',
                       help='forcibly optimise')
    group.add_argument('-l', '--link-only', action='store_true',
                       help='link only, do not optimise')
    args = parser.parse_args()

    if args.force:
        optimise_all()
    elif not args.link_only:
        optimise_all(older_than=datetime.timedelta(weeks=1))

    link_all()
